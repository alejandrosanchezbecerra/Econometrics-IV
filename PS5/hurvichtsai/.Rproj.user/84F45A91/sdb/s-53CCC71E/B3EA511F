{
    "collab_server" : "",
    "contents" : "\n#' Generate a random sample of an VAR(p) m-variate time series.\n#'\n#' @param Phi Transition Matrix\n#' @param Sigma Covariance of error terms\n#' @param p Order of VAR(p)\n#' @param m Number of dimensions\n#' @param n Number of observations\n#' @param NumLags Number of pre-data obs set to zero.\n#'\n#' @return mx(n+NumLags) matrix\n#' @export\n#'\n#' @examples\nsample_data <- function(Phi,Sigma,p,m,n,NumLags,...) {\n\n  epsilon <- MASS::mvrnorm(n+NumLags+1,mu=rep(0,m),Sigma=Sigma)\n  data    <- matrix(0,n+NumLags+1,2)\n\n  for(t in (NumLags+1):(n+NumLags+1)) {\n\n    data[t,] <- epsilon[t,]\n    order    <- 1\n\n    while(order <= p) {\n      data[t,] <- data[t,]+matrix(c(data[t-order,]),1,2)%*%t(Phi[[order]])\n      order    <- order+1\n    }\n\n  }\n\n  return(data)\n\n}\n\n#' Negative log-likelihood\n#'\n#' @param param Vector of parameters\n#' @param Y m-variate time series\n#' @param X lagged matrix of order (p). Does not include constant.\n#' @param p Order of VAR(p)\n#' @param m Dimension of time series\n#'\n#' @return Negative log-likelihood up to a constant\n#' @export\n#'\n#' @examples\nlik_VAR <- function(param,Y,X,p,m,n) {\n\n  coeff <- get_parameters(param,p,m)\n  beta  <- coeff$beta\n  Sigma <- coeff$Sigma\n  lik   <- n*log(det(Sigma))+\n           psych::tr((Y-X%*%beta)%*%solve(Sigma)%*%t(Y-X%*%beta))\n\n  return(lik)\n\n}\n\nconc_lik_VAR <- function(Sigma_vec,beta,Y,X,p,m,n) {\n\n  Sigma <- get_Sigma(Sigma_vec,m)\n  lik   <- n*log(det(Sigma))+\n           psych::tr((Y-X%*%beta)%*%solve(Sigma)%*%t(Y-X%*%beta))\n\n  return(lik)\n\n}\n\n#' Obtain maximum likelihood estimate\n#'\n#' @param data mx(n+NumLags) matrix\n#' @param m Number of dimensions of time series\n#' @param p Order of VAR(p)\n#' @param NumLags Maximum number of lags set to zero in pre-data observations.\n#'\n#' @return\n#' @export\n#'\n#' @examples\nmle_VAR <- function(data,m,p,n,NumLags) {\n\n  Y <- data[(NumLags+1):(n+NumLags),]\n  X <- get_regressorMat(data,NumLags+1,n,p)\n\n  # USE VAR as initial guess to speed up.\n  model_VAR  <- vars::VAR(as.data.frame(data[(NumLags-p+1):(n+NumLags),]),\n                          p = p,type=\"none\")\n  beta       <- t(vars::Bcoef(model_VAR))\n\n  # Bmat <- matrix(0,2,2)\n  # Bmat[lower.tri(Bmat,diag=TRUE)] <- NA\n  # Sigma <- SVAR(model_VAR,estmethod=\"direct\",Amat=diag(2),Bmat=Bmat)$Sigma.U/100\n\n  # beta_guess <- cbind(model_VAR$varresult$V1$coefficients,\n  #                   model_VAR$varresult$V2$coefficients)\n  # Sigma_guess <- summary(model_VAR)$covres\n  # init_guess <- get_param_vec(beta = beta_guess,Sigma = Sigma_guess )\n\n#  init_guess <- get_param_vec(beta = matrix(0,m^2,p),\n#                              Sigma = diag(m) )\n\n  init_guess <- get_Sigma_vec(Sigma=summary(model_VAR)$covres)\n  model     <- optim(par=init_guess,\n                     fn=function(Sigma) {conc_lik_VAR(Sigma,beta,Y,X,p,m,n)},\n                     method=\"L-BFGS-B\")\n  est_coef  <- model$par\n  Sigma     <- get_Sigma(est_coef,m)\n\n  # ls(summary(vars::VAR(as.data.frame(data[(NumLags-p+2):(n+NumLags+1),]),\n  #          p = p,type=\"none\")))\n\n  # summary(vars::VAR(as.data.frame(data[(NumLags-p+1):(n+NumLags),]),\n  #                  p = p,type=\"none\"))$corres\n\n  #model     <- optim(par=init_guess,\n  #                   fn=function(par) {lik_VAR(par,Y,X,p,m,n)},\n  #                   method=\"L-BFGS-B\")\n  #est_coef  <- model$par\n  #param     <- get_parameters(est_coef,p,m)\n\n  # grad(function(par) {lik_VAR(par,Y,X,p,m,n)},est_coef)\n\n  # return(param)\n\n  return(list(beta=beta,\n              Sigma=Sigma))\n\n}\n\n#' Construct stacked regressor matrix of lags of order p\n#'\n#' @param Z  Original time series\n#' @param n0 Initial observation\n#' @param n  Number of observations\n#' @param p  Order of VAR(p)\n#'\n#' @return\n#' @export\n#'\n#' @examples\nget_regressorMat <- function(Z,n0,n,p) {\n\n  if(p == 1) {\n    X <- Z[(n0-1):((n0-1)+(n-1)),]\n\n  } else if (p >= 1) {\n\n    X <- Z[(n0-1):((n0-1)+(n-1)),]\n\n    for( j in 2:p) {\n      X <- cbind(X,Z[(n0-j):((n0-j)+(n-1)),])\n    }\n  }\n\n  return(X)\n\n}\n\n#' Convert a vector of parameters into beta and Sigma matrices\n#'\n#' @param param First $p*(m^2)$ parameters are beta. The rest\n#' are Sigma. The parameters are the cells of the Cholesky decomposition.-\n#' @param p Order of VAR(p)\n#' @param m Number of dimensions of time series\n#'\n#' @return\n#' @export\n#'\n#' @examples\nget_parameters <- function(param,p,m) {\n\n  beta      <- matrix(param[1:(p*(m^2))],m*p,m)\n  cholSigma <- matrix(0,m,m)\n  cholSigma[lower.tri(cholSigma,diag=TRUE)] <-  param[(p*(m^2)+1):length(param)]\n  Sigma     <- cholSigma%*%t(cholSigma )\n\n  return(list(beta = beta,Sigma=Sigma))\n\n}\n\nget_Sigma <- function(Sigma_vec,m) {\n\n  cholSigma <- matrix(0,m,m)\n  cholSigma[lower.tri(cholSigma,diag=TRUE)] <-  Sigma_vec\n  Sigma     <- cholSigma%*%t(cholSigma )\n\n  return(Sigma)\n\n}\n\nget_Sigma_vec <- function(Sigma) {\n\n  Sigma <- Sigma\n  cholSigma <- t(chol(Sigma))\n  cholSigma <- cholSigma[lower.tri(cholSigma,diag=TRUE)]\n\n  return(cholSigma)\n\n}\n\n\n#' Convert beta and Sigma matrices into a vector of parameters\n#'\n#' @param beta  Stacked matrix of transition matrices (Phi)\n#' @param Sigma Covariance matrix of error terms\n#'\n#' @return Vector of parameters. The cells for Sigma correspond to the Cholesky\n#' decomposition.\n#' @export\n#'\n#' @examples\nget_param_vec <- function(beta,Sigma) {\n\n  Sigma <- Sigma\n  cholSigma <- t(chol(Sigma))\n  cholSigma <- cholSigma[lower.tri(cholSigma,diag=TRUE)]\n\n  return(c(as.vector(beta),cholSigma))\n\n}\n\n#' Title\n#'\n#' @param Phi\n#' @param m\n#' @param p\n#'\n#' @return\n#' @export\n#'\n#' @examples\nPhi_to_Beta <- function(Phi,m,p) {\n\n  beta  <- matrix(0,0,m)\n  order <- 1\n\n  while ( order <= p ) {\n    beta  <- rbind(beta,t(Phi[[order]]))\n    order <- order+1\n  }\n\n  return(beta)\n}\n\n#' Title\n#'\n#' @param beta\n#' @param m\n#' @param p\n#'\n#' @return\n#' @export\n#'\n#' @examples\nBeta_to_Phi <- function(beta,m,p) {\n\n  Phi <- list()\n\n  order <- 1\n  while ( order <= p ) {\n    Phi[[order]] <- t(beta[(m*(order-1)+1):(order*m),1:m])\n    order        <- order+1\n  }\n\n  return(Phi)\n}\n\n\n#' Title\n#'\n#' @param Phi\n#' @param m\n#' @param p\n#' @param n\n#'\n#' @return\n#' @export\n#'\n#' @examples\nconstruct_H <- function(Phi,m,p,n) {\n\n  H <- matrix(0,m*n,m*n)\n  stacked_Phi <- matrix(NA,0,m)\n\n  Phi\n\n  for(i in n:1){\n\n    # print(i)\n\n    if( i == n) {\n      stacked_Phi <- diag(m)\n    } else {\n      if( n-i <= p ) {\n        stacked_Phi <- rbind(stacked_Phi,-Phi[[n-i]])\n      } else {\n        stacked_Phi <- rbind(stacked_Phi,matrix(0,m,m))\n      }\n    }\n\n    H[((i-1)*m+1):(n*m),((i-1)*m+1):(i*m)] <- stacked_Phi\n\n  }\n\n  return(H)\n\n}\n\n# hola <- example2()\n# hola$Phi0\n\n# Phi_to_Beta(hola$Phi0,hola$m,hola$p)\n",
    "created" : 1489995755111.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "490311007",
    "id" : "B3EA511F",
    "lastKnownWriteTime" : 1489996828,
    "last_content_update" : 1489996828634,
    "path" : "~/GITHUB_FOLDERS/Econometrics-IV/PS5/hurvichtsai/R/helper_functions.R",
    "project_path" : "R/helper_functions.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}